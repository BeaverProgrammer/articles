# JavaScript 事件

本文讨论的范畴为客户端（浏览器）事件。

## 事件（event）

事件就是发生的事，基本可以分为以下几类：

1. 最主要的，用户的操作，比如点击，输入
2. 浏览器相关事件，比如 window.onload
3. 网络相关事件，比如 AJAX 的 readystatechage
4. 计时器相关的事件，比如 setInterval 的周期事件

## 事件处理（event handle）

一个 web 应用程序的执行有两个阶段，第一个阶段是静态页面的解析，另一个就是事件处理。

当一个事件触发的时候，这个事件被放入事件队列里（event queue），事件循环（event loop）会不断地检测事件队列是否有事件。

如果事件队列里有事件，浏览器会执行最先进入队列的事件所注册的事件监听函数。这个函数执行完毕后再处理下一个事件。

## 注册事件监听函数（event registration）

如上所述，事件处理的方式是执行其注册的监听函数。注册事件监听函数有两种途径：

1. 给触发事件的目标（target, 主要是元素）的特殊属性赋值一个监听函数。
2. target.addEventListener 方法。

```js
// 1. 函数赋值给目标的属性
window.onload = function () {
  console.log('页面加载完毕');
}

button.onclick = function() {
  alert('你再点我试试！');
}

// 2. addEventListener
button.addEventListener('click', function() {
  alert('点我100下有奇迹发生');
});
```

这两种方式的主要区别是，赋值给属性显然只能注册一个函数，因为再赋值会覆盖。而第二种方式可以注册多个监听函数。

次要的区别是，属性可以置于 html 文档的行内，这时函数以类似 eval 参数的形式存在，又因为这时耦合了 html 和 js，因而，这不是被推荐的方式。

用哪种方式试情况而定，第一种较随意和临时，第二种较正规和主流。

## 事件的传播（event propagation)

有趣的是，在一个元素上的事件会传播到其它元素，就好象其它元素也发生了这个事件。

事件的传播有两个过程：

1. 捕获阶段（event capture) ，从根元素（document.documentElement， 也就是 html 元素）向触发事件的目标元素（target）传递。
2. 冒泡阶段（event bubble) ，跟捕获阶段相反。

这两个阶段的传播路径是根据 DOM 树进行的，这条路经上的所有节点都触发与目标元素事件完全一致的事件。

初学时，我很不解，我在一个 button 上点一下，为何其它元素也被点了一下，不是变态么。

假如其它元素也注册了点击的监听函数，那这些函数不是也执行了么，而我要的只是执行这个 button 的函数！

这确实是事件传播的一个小弊端，不过是很方便解决的，相比较它带来的好处，这个弊端完全不是问题。

解决这个小弊端, 我想到的有两种方式：

第一种，从源头禁止事件的传播：

```js
button.addEventListener('click', function(event) {
  // 做一些该做的事情
  // 然后，添加这么一句，位置不限
  event.stopPropagation();
});
```
第二种，在其它元素的事件监听函数内检测目标元素：

```js
otherElements.addEventListener('click', function(event) {
  if (this !== event.target) {
    return;
  }
  // 检测, 若触发点击的不是本元素就什么也不做
  // 否则，执行后续的代码
);
```

这里 event 是事件对象，是监听函数的实参值，形参名可以任意，推荐用 event。

事件对象包含了关于事件的信息和方法。

弊端解决了，该谈谈事件传播的好处了。不过先了解一下监听函数的类型是个不错的开始。

## 监听函数的类型

属性赋值的监听函数是无类型的，因为它是 DOM 0 级的产物，而 DOM 0 级只有冒泡阶段。

前面使用 addEventListener 时没有用到第三个参数，默认为 false, 表示不是捕获类型（即为冒泡类型），如果显示设定为 true, 表示为捕获类型。

它们的类型决定了它们是在事件传播的哪一个阶段被执行。

## 事件代理（event delegation）

就目前而言，我能想到事件传播最大的好处就是事件代理了。

事件代理就是将某个元素的事件监听函数注册到另一个元素上面。

鉴于实际应用，事件捕获阶段的代理很少用到，绝大部分的应用是事件冒泡阶段。

### 如何实现事件代理

原则是，在尽可能近的而又必要的祖先元素或父元素上面去代理。

一个简单的例子：

```js
ancestor.addEventListener('click', function(event) {
  // do something about event.target or not or other
});

children.click();   // 当然这里只是示意触发了 _点击_ 事件
```
子元素的事件冒泡到了某个祖先元素，然后执行这个祖先元素上面的监听函数。这个监听函数跟注册到子元素上几乎没分别（this 可以通过 target 转）。

那，为什么是这个原则？

你当然可以将所有的监听函数注册到 root 上，有时是可以的，但当应用扩展时，你可能希望分解然后区分对待，对吧？

### 为什么需要事件代理

#### 动态创建元素

当动态创建元素时，这些新加入 DOM 的元素是不可能有监听函数的，而如果每次重新给新元素注册监听函数是不划算的。

想想看，你创建了一些元素，遍历它们，挨个给这些元素注册一个或多个监听函数，重复着操作已经对其它类似元素早已做过的工作。

**Don't Repeat Youself** right?

这时使用事件代理，一切都变得了那么美好。

#### 节省时间和空间

无论怎样，或多或少，挨个给每个元素注册监听函数的这样一种操作，都会消耗时间和硬件资源，当元素众多时，使用事件代理是一个很好的处理方式。

## 兼容性问题

当然指的是 < IE9 了, 除了 DOM 0 级，它的 event 相关的 API 跟标准是不一样的，比如：

1. 不是 addEventListener 而是 attachEvent
2. 不是回调的参数 event 而是 window.event, 很怪对吧
3. 不是 event.target 而是 event.sourceElement 
4. 很多其它的不同

当然，随着 ES6 ES7 甚至 ES8 时代的到来，旧浏览器的逐步淘汰，我们越来越可能不用考虑这些兼容性问题了。但，就目前而言，我倾向于使用 jQuery。

相信了解了这些 *事件* 相关的基础之后，我们能够更好地理解和使用 jQuery。

## 参考

学了各种资料，才有了这些总结，我想获益最大的是 jquery in action 和 jquery 官网, 其次是 犀牛书 和 secrets of the javascript ninja
