# JavaScript 事件

本文讨论的范畴为客户端（浏览器）事件。

## 事件（event）

事件就是发生的事，基本可以分为以下几类：

1. 最主要的，用户的操作，比如点击，输入
2. 浏览器相关事件，比如 window.onload
3. 网络相关事件，比如 AJAX 的 readystatechage
4. 计时器相关的事件，比如 setInterval 的周期事件

## 事件处理（event handle）

一个 web 应用程序的执行有两个阶段，第一个阶段是静态页面的解析，另一个就是事件处理。

当一个事件触发并完成的时候，这个事件被放入事件队列里（event queue），事件循环（event loop）会不断地检测事件队列是否有事件。

如果事件队列里有事件，浏览器会执行最先进入队列的事件所注册的事件监听函数。这个函数执行完毕后按顺序再处理下一个事件。

## 注册事件监听函数（event registration）

如上所述，事件处理的方式是按顺序执行其注册的监听函数。

这里提到的按顺序有两层意思，一层是按事件发生的先后顺序，另一层是按某个事件监听函数的注册顺序，因为一个事件可有多个监听函数。

注册事件监听函数有两种途径：

1. 给触发事件的目标（target, 主要是元素, 本文提到的元素指 DOM 元素）的特殊属性赋值一个监听函数。
2. target.addEventListener 方法。

```js
// 1. 函数赋值给目标的属性
window.onload = function () {
  console.log('页面加载完毕');
}

button.onclick = function() {
  alert('你再点我试试！');
}

// 2. addEventListener
button.addEventListener('click', function() {
  alert('点我100下有奇迹发生');
});
```

这两种方式的主要区别是，赋值给属性显然只能注册一个函数，因为再赋值会覆盖。而第二种方式可以注册多个监听函数。

次要的区别是，属性可以置于 html 文档的行内，这时函数以类似 eval 参数的形式存在，又因为这时耦合了 html 和 js，因而，这不是被推荐的方式。

用哪种方式试情况而定，第一种较随意和临时，第二种较正规和主流。

## 异步性（asynchronous）

我们经常提到异步性，那么，我们在谈论异步的时候我们在谈论什么？

### 事件的异步性

一个事件的触发和完成是需要时间的，有的耗时还较长，这时不应阻塞其它事件的发生。

**一个事件不阻碍另一个事件的发生, 这就是事件的异步性**

事实上，这是异步的本质。

### 事件处理的异步性

如前所述，事件完成后，被放入事件队列，如果之前的事件（如果有的话）的监听函数全部执行完毕，这个事件的监听函数就会得到执行。

这就是所谓的事件处理。因而，我们说事件处理（handling event）时，指的是监听函数（event handler）的执行。

我们知道，JavaScript 是单线程的，执行函数时不会再执行其它代码。那为什么事件处理是异步的呢？

这时我们应该了解同步的概念，同步是指事件的整个过程是阻塞的（甚至就是函数硬编码执行的），据我所知客户端是没有同步事件的，而 nodejs 提供了事件的同步版本。

比如，fs.readFileSync, 这个函数的主要作用就是读取硬盘文件，然后返回相关格式的数据，我们知道，硬盘读取相较而言是很耗时间的（更耗时的可能是到另一台服务器获取数据了），如果是同步的话，这时程序什么都干不了就等着数据读完，然后再执行对应的函数以及后续的代码。

异步的话，函数被延缓到事件完成之后执行，不影响后续代码运行以及期间其它事件的触发。

**监听函数被延缓执行从而不阻塞后续代码的执行，就是事件处理的异步性。**

nodejs 的异步性按这个理解，可以知道 nodejs 节约的主要时间是事件的完成时间，因为事件是异步的，但，到了事件完成执行监听函数时，这个函数执行时间是节约不了的（单线程）。服务器端的事件比如网络传输和硬盘读取相对都是很耗时间的，有了 nodejs (JavaScript) 异步性（非阻塞），实现了较其它一些语言的优势。

### 异步的本质

如前所述，异步的本质是事件的异步，所谓事件处理的异步（或者说函数的异步调用）不过是事件异步的表现形式。

## 事件的传播（event propagation)

有趣的是，在一个元素上的事件会传播到其它元素，就好象其它元素也发生了这个事件。

事件的传播有两个过程：

1. 捕获阶段（event capture) ，从根元素（document.documentElement， 也就是 html 元素）向触发事件的目标元素（target）传递。
2. 冒泡阶段（event bubble) ，跟捕获阶段相反。

这两个阶段的传播路径是根据 DOM 树进行的，这条路经上的所有节点都触发与目标元素事件完全一致的事件。

初学时，我很不解，我在一个 button 上点一下，为何其它元素也被点了一下，不是变态么。

假如其它元素也注册了点击的监听函数，那这些函数不是也执行了么，而我要的只是执行这个 button 的函数！

这确实是事件传播的一个小弊端，不过是很方便解决的，相比较它带来的好处，这个弊端完全不是问题。

解决这个小弊端, 我想到的有两种方式：

第一种，从源头禁止事件的传播：

```js
button.addEventListener('click', function(event) {
  // 做一些该做的事情
  // 然后，添加这么一句，位置不限
  event.stopPropagation();
});
```
第二种，在其它元素的事件监听函数内检测目标元素：

```js
otherElements.addEventListener('click', function(event) {
  if (this !== event.target) {
    return;
  }
  // 检测, 若触发点击的不是本元素就什么也不做
  // 否则，执行后续的代码
);
```

这里 event 是事件对象，是监听函数的实参值，形参名可以任意，推荐用 event。

事件对象包含了关于事件的信息和方法。

弊端解决了，该谈谈事件传播的好处了。不过先了解一下监听函数的类型是个不错的开始。

## 监听函数的类型

属性赋值的监听函数是无类型的，因为它是 DOM 0 级的产物，而 DOM 0 级只有冒泡阶段。

前面使用 addEventListener 时没有用到第三个参数，默认为 false, 表示不是捕获类型（即为冒泡类型），如果显示设定为 true, 表示为捕获类型。

它们的类型决定了它们是在事件传播的哪一个阶段被执行。

## 事件代理（event delegation）

就目前而言，我能想到事件传播最大的好处就是事件代理了。

事件代理就是将某个元素的事件监听函数注册到另一个元素上面。

鉴于实际应用，事件捕获阶段的代理很少用到，绝大部分的应用是事件冒泡阶段。

### 如何实现事件代理

一个简单的例子：

```js
ancestor.addEventListener('click', function(event) {
  // do something about event.target or not or other
});

children.click();   // 当然这里只是示意触发了 _点击_ 事件
```
子元素的事件冒泡到了某个祖先元素，然后执行这个祖先元素上面的监听函数。这个监听函数跟注册到子元素上几乎没分别（this 可以通过 target 转）。

原则是，在尽可能近的而又必要的祖先元素或父元素上面去代理。

那，为什么是这个原则？

你当然可以将所有的监听函数注册到 root 上，有时是可以的，但当应用扩展时，你可能希望分解然后区分对待，对吧？

### 为什么需要事件代理

#### 动态创建元素

当动态创建元素时，这些新加入 DOM 的元素是不可能有监听函数的，而如果每次重新给新元素注册监听函数是不划算的。

想想看，你创建了一些元素，遍历它们，挨个给这些元素注册一个或多个监听函数，重复着操作已经对其它类似元素早已做过的工作。

**Don't Repeat Youself** right?

这时使用事件代理，一切都变得了那么美好。

#### 节省时间和空间

无论怎样，或多或少，挨个给每个元素注册监听函数的这样一种操作，都会消耗时间和硬件资源，当元素众多时，使用事件代理是一个很好的处理方式。

## 兼容性问题

当然指的是 < IE9 了, 除了 DOM 0 级，它的 event 相关的 API 跟标准是不一样的，比如：

1. 不是 addEventListener 而是 attachEvent
2. 不是回调的参数 event 而是 window.event, 很怪对吧
3. 不是 event.target 而是 event.sourceElement 
4. 很多其它的不同

当然，随着 ES6 ES7 甚至 ES8 时代的到来，旧浏览器的逐步淘汰，我们越来越可能不用考虑这些兼容性问题了。但，就目前而言，我倾向于使用 jQuery。

相信了解了这些 *事件* 相关的基础之后，我们能够更好地理解和使用 jQuery。

## 参考

学了各种资料和思考后，才有了这些总结，它们是 jquery in action, jquery 官网, secrets of the javascript ninja 和犀牛书
